"""
python程序是由代码块构成的. ⼀一个代码块的⽂文本作为python程序执⾏行行的单元.
代码块: ⼀一个模块, ⼀一个函数, ⼀一个类, 甚⾄至每⼀一个command命令都是⼀一个代码块.
⼀一个⽂文件也是⼀一 个代码块, eval()和exec()执⾏行行的时候也是⼀一个代码块

"""

#   

#1. id()
# a = [1,2,22,3,3,343,2,4,2342,233]
# b = a  # 明天讲深浅拷贝
#
# print(id(b))
# print(id(a))
#
#
# a = 1000
# print(id(a)) #内存的开辟是有解释器来完成的,内存地址不一定每次都一样

#2. is 和 ==


# ==判断的是值是否相同
# is判断是否都指向同一个内存地址(是不是同一个对象)

# lst1 = [1,2,3]
# lst2 = [1,2,3]
# print(lst1 == lst2)
# print(lst1 is lst2) #不是同一个对象
#
#
# a = 'alex'
# b = 'alex'
# print(a == b)
# print(a is b) # 结果两个都是true, 在python中默认会把数字,字符串,布尔值进行缓存

# 一. 当我们在控制台的时候,代码块与代码块之间
 # 1. 数字:  范围 -5 - 256之间的整数这个时候 a is b 会是True,满足这个范围才会去缓存,不在这个范围都是新值
 # 2. 字符串:
    #长于小于等于1 会默认缓存
    #长度大于1,如果字符串中只有字母数字下划线则缓存要大,出现特别符号则不缓存,如@
    #乘法得到的字符串:
      #1.如果乘数是1, 和上面两个方案一直
      #2.如果乘数不是1,最终长度不能超过20
    #手动指定缓存 from sys import intern    intern()指定缓存的内容

# from sys import intern
# a = "alex@sb.com" * 5
# b = "alex@sb.com" * 5
# print(a is b)  #结果应该是false
#
# a = intern("alex@sb.com" * 5)
# b = intern("alex@sb.com" * 5)
# print(a is b)  #结果应该是true

 # 3. 布尔值   默认是缓存的


# 二. py文件里一个代码块内部,只会缓存int str bool,也有自己的小数据池,缓存的范围要比外面的代码块的数据池范围
 #  1. 数字, 都会缓存, 运算的结果不缓存(-5-256会缓存)
 #  2. 字符串: 默认的字符串都会缓存
 #  3. 布尔值, 默认缓存
